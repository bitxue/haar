<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ndHaar: /Users/clackn/src/haar/src/haar.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>/Users/clackn/src/haar/src/haar.c</h1><a href="src_2haar_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00125"></a>00125 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00126"></a>00126 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00127"></a>00127 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00130"></a>00130 
<a name="l00131"></a><a class="code" href="src_2haar_8c.html#a514396dd60fa0621c83072091fb2a0cd">00131</a> <span class="preprocessor">#define SQRT2    1.41421356237309504880</span>
<a name="l00132"></a><a class="code" href="src_2haar_8c.html#a58e26e9a27c188d602305ec0bc13149a">00132</a> <span class="preprocessor"></span><span class="preprocessor">#define INVSQRT2 0.70710678118654752440</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>
<a name="l00134"></a><a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119">00134</a> <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>;          
<a name="l00135"></a><a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680">00135</a> <span class="keyword">typedef</span> int64_t <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>; 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">// UTIL ////////////////////////////////////////////////////////////////////////</span>
<a name="l00138"></a>00138 
<a name="l00144"></a><a class="code" href="ops_8h.html#a6ad4524b0b7a5e54912a013821627e51">00144</a> <span class="keywordtype">unsigned</span> <a class="code" href="src_2haar_8c.html#a6ad4524b0b7a5e54912a013821627e51" title="A fast log2 Algorithm taken from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog...">u32log2</a>(uint32_t v)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> LogTable256[256] =
<a name="l00147"></a>00147   {
<a name="l00148"></a>00148 <span class="preprocessor">#define LT(n) n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>    -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
<a name="l00150"></a>00150     <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(4), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(5), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(5), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(6), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(6), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(6), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(6),
<a name="l00151"></a>00151     <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7), <a class="code" href="src_2haar_8c.html#a835a564399f4498da6ccbef2dcdd277e">LT</a>(7)
<a name="l00152"></a>00152   };
<a name="l00153"></a>00153 <span class="preprocessor">#undef LT</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span>
<a name="l00155"></a>00155   <span class="keywordtype">unsigned</span> r;                  <span class="comment">// r will be lg(v)</span>
<a name="l00156"></a>00156   <span class="keyword">register</span> uint32_t t, tt;     <span class="comment">// temporaries</span>
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keywordflow">if</span> ((tt = v &gt;&gt; 16))
<a name="l00159"></a>00159   {
<a name="l00160"></a>00160     r = (t = tt &gt;&gt; 8) ? 24 + LogTable256[t] : 16 + LogTable256[tt];
<a name="l00161"></a>00161   }
<a name="l00162"></a>00162   <span class="keywordflow">else</span>
<a name="l00163"></a>00163   {
<a name="l00164"></a>00164     r = (t = v &gt;&gt; 8) ? 8 + LogTable256[t] : LogTable256[v];
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166   <span class="keywordflow">return</span> r;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00174"></a><a class="code" href="ops_8h.html#a9592a5ae5d02224708d468eb48c9a6f8">00174</a> <span class="keywordtype">unsigned</span> <a class="code" href="src_2haar_8c.html#a9592a5ae5d02224708d468eb48c9a6f8" title="A fast log2 Algorithm taken from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog...">u64log2</a>(uint64_t v)
<a name="l00175"></a>00175 { <span class="keyword">register</span> uint64_t tt;
<a name="l00176"></a>00176   <span class="keywordflow">return</span> (tt=v&gt;&gt;32)?(32+<a class="code" href="src_2haar_8c.html#a6ad4524b0b7a5e54912a013821627e51" title="A fast log2 Algorithm taken from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog...">u32log2</a>((uint32_t)tt)):<a class="code" href="src_2haar_8c.html#a6ad4524b0b7a5e54912a013821627e51" title="A fast log2 Algorithm taken from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog...">u32log2</a>((uint32_t)v);
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00182"></a>00182 <span class="keyword">static</span>
<a name="l00183"></a><a class="code" href="src_2haar_8c.html#a1c2416b3bf0752f0f8b4da8deb25d8fa">00183</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a1c2416b3bf0752f0f8b4da8deb25d8fa" title="Internally used utility function.">copy_recurse</a>(int64_t m, int64_t idim,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *ostrides,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *in,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *istrides)
<a name="l00184"></a>00184 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i,os,is;
<a name="l00185"></a>00185   <span class="keywordflow">if</span>(idim&lt;0) { *out = *in; <span class="keywordflow">return</span>; }
<a name="l00186"></a>00186   <span class="keywordflow">if</span>(idim&lt;m)
<a name="l00187"></a>00187   { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> nelem = shape[idim];
<a name="l00188"></a>00188     <span class="keywordflow">while</span>(idim--)
<a name="l00189"></a>00189       nelem *= shape[idim]; <span class="comment">// FIXME?? suspect that nelem == ostrides[m] bc of conditions on m</span>
<a name="l00190"></a>00190     memcpy(out,in,<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>)*nelem);
<a name="l00191"></a>00191     <span class="keywordflow">return</span>;
<a name="l00192"></a>00192   }
<a name="l00193"></a>00193   os = ostrides[idim];
<a name="l00194"></a>00194   is = istrides[idim];
<a name="l00195"></a>00195   <span class="keywordflow">for</span>(i=0;i&lt;shape[idim];++i)
<a name="l00196"></a>00196     <a class="code" href="src_2haar_8c.html#a1c2416b3bf0752f0f8b4da8deb25d8fa" title="Internally used utility function.">copy_recurse</a>(m,idim-1,shape,out+os*i,ostrides,in+is*i,istrides);
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00226"></a><a class="code" href="src_2haar_8c.html#ac7424b993ab6cabfa84dcaaca25201a6">00226</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#ac7424b993ab6cabfa84dcaaca25201a6" title="Copy a subvolume of one n-dimensional scalar field into another scalar field.">copy</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *ostrides,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *in,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *istrides)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228   int64_t m;
<a name="l00229"></a>00229   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *oshape,*ishape;
<a name="l00230"></a>00230   <span class="comment">// 0. Nothing to do?</span>
<a name="l00231"></a>00231   <span class="keywordflow">if</span>(out==in) <span class="keywordflow">return</span>;
<a name="l00232"></a>00232   <span class="comment">// 1. Find max index such that a block copy is ok</span>
<a name="l00233"></a>00233   <span class="comment">//      ostrides[j]==istrides[j] and oshape[j]==ishape[j]==shape[j] for j&lt;i</span>
<a name="l00234"></a>00234   <span class="comment">//    where oshape and ishape are the shapes derived from the input</span>
<a name="l00235"></a>00235   <span class="comment">//      strides.</span>
<a name="l00236"></a>00236   <span class="keywordflow">if</span>(!(oshape=alloca(<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>)*ndim*2))) <span class="keywordflow">goto</span> MemoryError;
<a name="l00237"></a>00237   ishape=oshape+ndim;
<a name="l00238"></a>00238   <span class="comment">// stride[i] = shape[i-1]*shape[i-2]*...*shape[0]</span>
<a name="l00239"></a>00239   <span class="comment">// so shape[i]  = stride[i+1]/stride[i]</span>
<a name="l00240"></a>00240   <span class="keywordflow">for</span>(m=0;m&lt;ndim;++m)
<a name="l00241"></a>00241   { ishape[m] = istrides[m+1]/istrides[m];
<a name="l00242"></a>00242     oshape[m] = ostrides[m+1]/ostrides[m];
<a name="l00243"></a>00243   }
<a name="l00244"></a>00244   m=0;
<a name="l00245"></a>00245   <span class="keywordflow">if</span>(ostrides[0]==1 &amp;&amp; istrides[0]==1)
<a name="l00246"></a>00246     <span class="keywordflow">for</span>(m=0;m&lt;ndim
<a name="l00247"></a>00247         &amp;&amp; ostrides[m]==istrides[m]
<a name="l00248"></a>00248         &amp;&amp;   oshape[m]==ishape[m]
<a name="l00249"></a>00249         &amp;&amp;    shape[m]==oshape[m]
<a name="l00250"></a>00250         ;++m);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">// 2. Recursively copy on outer dimension (max st shape is not 1)</span>
<a name="l00253"></a>00253   <span class="comment">//    use memcpy when dimension gets to dimension i.</span>
<a name="l00254"></a>00254   <a class="code" href="src_2haar_8c.html#a1c2416b3bf0752f0f8b4da8deb25d8fa" title="Internally used utility function.">copy_recurse</a>(m,ndim-1,shape,out,ostrides,in,istrides);
<a name="l00255"></a>00255   <span class="keywordflow">return</span>;
<a name="l00256"></a>00256 MemoryError:
<a name="l00257"></a>00257   fprintf(stderr,<span class="stringliteral">&quot;Could not allocate block of %lld elements on stack.&quot;</span>,2*ndim);
<a name="l00258"></a>00258   exit(1);
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">// nD Array Ops  ///////////////////////////////////////////////////////////////</span>
<a name="l00288"></a><a class="code" href="src_2haar_8c.html#ad497b799087e23d1980f46ff288406bd">00288</a> <span class="comment"></span><span class="keyword">typedef</span> void    (<a class="code" href="src_2haar_8c.html#ad497b799087e23d1980f46ff288406bd" title=" z[:] &amp;lt;- x[:] op y[:]">binary_vec_op_t</a>)(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> zst,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* x,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> xst,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* y,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> yst);
<a name="l00302"></a><a class="code" href="src_2haar_8c.html#acbfd4b11a813fb9bc8de44403ccec265">00302</a> <span class="keyword">typedef</span> void (<a class="code" href="src_2haar_8c.html#acbfd4b11a813fb9bc8de44403ccec265" title=" z[:] .op a">scalar_ip_vec_op_t</a>)(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>*,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>,<a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>);
<a name="l00303"></a>00303 
<a name="l00307"></a>00307 <span class="keyword">static</span>
<a name="l00308"></a><a class="code" href="src_2haar_8c.html#af4c3f134cd7ad5e95a526e1a94c2e7bf">00308</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#af4c3f134cd7ad5e95a526e1a94c2e7bf" title="Internally used utility function.">binary_op_recurse</a>(
<a name="l00309"></a>00309     int64_t m,
<a name="l00310"></a>00310     int64_t idim,
<a name="l00311"></a>00311     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,
<a name="l00312"></a>00312     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zst,
<a name="l00313"></a>00313     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* x,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *xst,
<a name="l00314"></a>00314     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* y,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *yst,
<a name="l00315"></a>00315     <a class="code" href="src_2haar_8c.html#ad497b799087e23d1980f46ff288406bd" title=" z[:] &amp;lt;- x[:] op y[:]">binary_vec_op_t</a> *f)
<a name="l00316"></a>00316 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i,ox,oy,oz;
<a name="l00317"></a>00317   <span class="keywordflow">if</span>(idim&lt;m)
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319     f(zst[m]/zst[0],z,zst[0],x,xst[0],y,yst[0]);
<a name="l00320"></a>00320     <span class="keywordflow">return</span>;
<a name="l00321"></a>00321   }
<a name="l00322"></a>00322   ox = xst[idim];
<a name="l00323"></a>00323   oy = yst[idim];
<a name="l00324"></a>00324   oz = zst[idim];
<a name="l00325"></a>00325   <span class="keywordflow">for</span>(i=0;i&lt;shape[idim];++i)
<a name="l00326"></a>00326     <a class="code" href="src_2haar_8c.html#af4c3f134cd7ad5e95a526e1a94c2e7bf" title="Internally used utility function.">binary_op_recurse</a>(m,idim-1,shape,z+oz*i,zst,x+ox*i,xst,y+oy*i,yst,f);
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00368"></a>00368 <span class="keyword">static</span>
<a name="l00369"></a><a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18">00369</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18" title="Applies a binary operation z=f(x,y) element-wise across n-dimensional scalar fields...">binary_op</a>(
<a name="l00370"></a>00370     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim,
<a name="l00371"></a>00371     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,
<a name="l00372"></a>00372     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zst,
<a name="l00373"></a>00373     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* x,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *xst,
<a name="l00374"></a>00374     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* y,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *yst,
<a name="l00375"></a>00375     <a class="code" href="src_2haar_8c.html#ad497b799087e23d1980f46ff288406bd" title=" z[:] &amp;lt;- x[:] op y[:]">binary_vec_op_t</a> *f)
<a name="l00376"></a>00376 {
<a name="l00377"></a>00377   int64_t m;
<a name="l00378"></a>00378   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zshape,*xshape,*yshape;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="comment">// 1. Find max index such that lower dimension indexes may be collapsed(vectorized)</span>
<a name="l00381"></a>00381   <span class="comment">//      ostrides[j]==istrides[j] and oshape[j]==ishape[j]==shape[j] for j&lt;i</span>
<a name="l00382"></a>00382   <span class="comment">//    where oshape and ishape are the shapes derived from the input</span>
<a name="l00383"></a>00383   <span class="comment">//      strides.</span>
<a name="l00384"></a>00384   <span class="keywordflow">if</span>(!(zshape=alloca(<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>)*ndim*3))) <span class="keywordflow">goto</span> MemoryError;
<a name="l00385"></a>00385   xshape=zshape+  ndim;
<a name="l00386"></a>00386   yshape=zshape+2*ndim;
<a name="l00387"></a>00387   <span class="keywordflow">for</span>(m=0;m&lt;ndim;++m)                                                           <span class="comment">// compute native shapes from strides</span>
<a name="l00388"></a>00388   { zshape[m] = zst[m+1]/zst[m];
<a name="l00389"></a>00389     xshape[m] = xst[m+1]/xst[m];
<a name="l00390"></a>00390     yshape[m] = yst[m+1]/yst[m];
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392   m=0;
<a name="l00393"></a>00393   <span class="keywordflow">for</span>(m=0;m&lt;ndim
<a name="l00394"></a>00394       &amp;&amp; zst[m]==xst[m]
<a name="l00395"></a>00395       &amp;&amp; zst[m]==yst[m]
<a name="l00396"></a>00396       &amp;&amp; zshape[m]==xshape[m]
<a name="l00397"></a>00397       &amp;&amp; zshape[m]==yshape[m]
<a name="l00398"></a>00398       &amp;&amp; zshape[m]== shape[m]
<a name="l00399"></a>00399       ;++m);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="comment">// 2. Recursively operate on outer dimension (max st shape is not 1)</span>
<a name="l00402"></a>00402   <span class="comment">//    use f when dimension gets to dimension i.</span>
<a name="l00403"></a>00403   <a class="code" href="src_2haar_8c.html#af4c3f134cd7ad5e95a526e1a94c2e7bf" title="Internally used utility function.">binary_op_recurse</a>(m,ndim-1,shape,z,zst,x,xst,y,yst,f);
<a name="l00404"></a>00404   <span class="keywordflow">return</span>;
<a name="l00405"></a>00405 MemoryError:
<a name="l00406"></a>00406   fprintf(stderr,<span class="stringliteral">&quot;Error: %s(%d)\n&quot;</span>
<a name="l00407"></a>00407                  <span class="stringliteral">&quot;\tCould not allocate block of %lld elements on stack.\n&quot;</span>,
<a name="l00408"></a>00408                  __FILE__,__LINE__,2*ndim);
<a name="l00409"></a>00409   exit(1);
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00413"></a>00413 <span class="keyword">static</span>
<a name="l00414"></a><a class="code" href="src_2haar_8c.html#ac9470df29a64cab4aef7b0be6fc30629">00414</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#ac9470df29a64cab4aef7b0be6fc30629" title="Internally used utility function.">scalar_ip_recurse</a>(
<a name="l00415"></a>00415     int64_t m,
<a name="l00416"></a>00416     int64_t idim,
<a name="l00417"></a>00417     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,
<a name="l00418"></a>00418     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *z,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zst,
<a name="l00419"></a>00419     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>  a,
<a name="l00420"></a>00420     <a class="code" href="src_2haar_8c.html#acbfd4b11a813fb9bc8de44403ccec265" title=" z[:] .op a">scalar_ip_vec_op_t</a> *f)
<a name="l00421"></a>00421 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i,oz;
<a name="l00422"></a>00422   <span class="keywordflow">if</span>(idim&lt;m)
<a name="l00423"></a>00423   {
<a name="l00424"></a>00424     f(zst[m]/zst[0],z,zst[0],a);
<a name="l00425"></a>00425     <span class="keywordflow">return</span>;
<a name="l00426"></a>00426   }
<a name="l00427"></a>00427   oz = zst[idim];
<a name="l00428"></a>00428   <span class="keywordflow">for</span>(i=0;i&lt;shape[idim];++i)
<a name="l00429"></a>00429     <a class="code" href="src_2haar_8c.html#ac9470df29a64cab4aef7b0be6fc30629" title="Internally used utility function.">scalar_ip_recurse</a>(m,idim-1,shape,z+oz*i,zst,a,f);
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00457"></a>00457 <span class="keyword">static</span>
<a name="l00458"></a><a class="code" href="src_2haar_8c.html#a7df1a1863594a2089914b3cdcaff0d3d">00458</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a7df1a1863594a2089914b3cdcaff0d3d" title="Applies a scalar function z=f(z;a) element-wise and in-place to an n-dimensional...">scalar_ip_op</a>(
<a name="l00459"></a>00459     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim,
<a name="l00460"></a>00460     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape,
<a name="l00461"></a>00461     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z,<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zst,
<a name="l00462"></a>00462     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> a,
<a name="l00463"></a>00463     <a class="code" href="src_2haar_8c.html#acbfd4b11a813fb9bc8de44403ccec265" title=" z[:] .op a">scalar_ip_vec_op_t</a> *f)
<a name="l00464"></a>00464 {
<a name="l00465"></a>00465   int64_t m;
<a name="l00466"></a>00466   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *zshape;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">// 1. Find max index such that lower dimension indexes may be collapsed(vectorized)</span>
<a name="l00469"></a>00469   <span class="comment">//      ostrides[j]==istrides[j] and oshape[j]==ishape[j]==shape[j] for j&lt;i</span>
<a name="l00470"></a>00470   <span class="comment">//    where oshape and ishape are the shapes derived from the input</span>
<a name="l00471"></a>00471   <span class="comment">//      strides.</span>
<a name="l00472"></a>00472   <span class="keywordflow">if</span>(!(zshape=alloca(<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>)*ndim*2))) <span class="keywordflow">goto</span> MemoryError;
<a name="l00473"></a>00473   <span class="comment">// stride[i]   = shape[i-1]*shape[i-2]*...*shape[0]</span>
<a name="l00474"></a>00474   <span class="comment">// so shape[i] = stride[i+1]/stride[i]</span>
<a name="l00475"></a>00475   <span class="keywordflow">for</span>(m=0;m&lt;ndim;++m)
<a name="l00476"></a>00476     zshape[m] = zst[m+1]/zst[m];
<a name="l00477"></a>00477   m=0;
<a name="l00478"></a>00478   <span class="keywordflow">for</span>(m=0;m&lt;ndim
<a name="l00479"></a>00479       &amp;&amp;  shape[m]==zshape[m]
<a name="l00480"></a>00480       ;++m);
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="comment">// 2. Recursively operate on outer dimension (max st shape is not 1)</span>
<a name="l00483"></a>00483   <span class="comment">//    use f when dimension gets to dimension i.</span>
<a name="l00484"></a>00484   <a class="code" href="src_2haar_8c.html#ac9470df29a64cab4aef7b0be6fc30629" title="Internally used utility function.">scalar_ip_recurse</a>(m,ndim-1,shape,z,zst,a,f);
<a name="l00485"></a>00485   <span class="keywordflow">return</span>;
<a name="l00486"></a>00486 MemoryError:
<a name="l00487"></a>00487   fprintf(stderr,<span class="stringliteral">&quot;Error: %s(%d)\n&quot;</span>
<a name="l00488"></a>00488                  <span class="stringliteral">&quot;\tCould not allocate block of %lld elements on stack.\n&quot;</span>,
<a name="l00489"></a>00489                  __FILE__,__LINE__,2*ndim);
<a name="l00490"></a>00490   exit(1);
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment">// VECTOR OPS //////////////////////////////////////////////////////////////////</span>
<a name="l00494"></a>00494 
<a name="l00496"></a>00496 <span class="keyword">static</span>
<a name="l00497"></a><a class="code" href="src_2haar_8c.html#aedf0aab756bab3863bb9d9aa706c7ff8">00497</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#aedf0aab756bab3863bb9d9aa706c7ff8" title="1D: zs = xs + ys">vadd</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> sty)
<a name="l00498"></a>00498 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i;
<a name="l00499"></a>00499   <span class="keywordflow">for</span>(i=0;i&lt;N;++i)
<a name="l00500"></a>00500     zs[i*stz] = xs[i*stx] + ys[i*sty];
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00504"></a><a class="code" href="src_2haar_8c.html#a8497d55ebb73435021a6b904eca920e4">00504</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a8497d55ebb73435021a6b904eca920e4" title="nD: zs = xs + ys">add</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *sty)
<a name="l00505"></a>00505 { <a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18" title="Applies a binary operation z=f(x,y) element-wise across n-dimensional scalar fields...">binary_op</a>(ndim,shape,zs,stz,xs,stx,ys,sty,<a class="code" href="src_2haar_8c.html#aedf0aab756bab3863bb9d9aa706c7ff8" title="1D: zs = xs + ys">vadd</a>);
<a name="l00506"></a>00506 }
<a name="l00507"></a>00507 
<a name="l00509"></a>00509 <span class="keyword">static</span>
<a name="l00510"></a><a class="code" href="src_2haar_8c.html#a6888a628ca5453a59553fb6202030b0f">00510</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a6888a628ca5453a59553fb6202030b0f" title="1D: zs = xs - ys">vsub</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> sty)
<a name="l00511"></a>00511 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i;
<a name="l00512"></a>00512   <span class="keywordflow">for</span>(i=0;i&lt;N;++i)
<a name="l00513"></a>00513     zs[i*stz] = xs[i*stx] - ys[i*sty];
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00517"></a><a class="code" href="src_2haar_8c.html#ae7c3bf6bb0f7f474a303c523a2afccbe">00517</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#ae7c3bf6bb0f7f474a303c523a2afccbe" title="nD: zs = xs - ys">sub</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *sty)
<a name="l00518"></a>00518 { <a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18" title="Applies a binary operation z=f(x,y) element-wise across n-dimensional scalar fields...">binary_op</a>(ndim,shape,zs,stz,xs,stx,ys,sty,<a class="code" href="src_2haar_8c.html#a6888a628ca5453a59553fb6202030b0f" title="1D: zs = xs - ys">vsub</a>);
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00522"></a>00522 <span class="keyword">static</span>
<a name="l00523"></a><a class="code" href="src_2haar_8c.html#aa3f0e6b4c070786bdaf3d97dc6132bb5">00523</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#aa3f0e6b4c070786bdaf3d97dc6132bb5" title="1D: zs = xs - 2*ys">vsub2</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> sty)
<a name="l00524"></a>00524 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i;
<a name="l00525"></a>00525   <span class="keywordflow">for</span>(i=0;i&lt;N;++i)
<a name="l00526"></a>00526     zs[i*stz] = xs[i*stx] - 2.0f*ys[i*sty];
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00530"></a><a class="code" href="src_2haar_8c.html#a7432241a308bae545e35ec116bd048ef">00530</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a7432241a308bae545e35ec116bd048ef" title="nD: zs = xs - 2*ys">sub2</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *sty)
<a name="l00531"></a>00531 { <a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18" title="Applies a binary operation z=f(x,y) element-wise across n-dimensional scalar fields...">binary_op</a>(ndim,shape,zs,stz,xs,stx,ys,sty,<a class="code" href="src_2haar_8c.html#aa3f0e6b4c070786bdaf3d97dc6132bb5" title="1D: zs = xs - 2*ys">vsub2</a>);
<a name="l00532"></a>00532 }
<a name="l00533"></a>00533 
<a name="l00535"></a>00535 <span class="keyword">static</span>
<a name="l00536"></a><a class="code" href="src_2haar_8c.html#abc9de506ab6649485024cc0ed80cf3f3">00536</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#abc9de506ab6649485024cc0ed80cf3f3" title="1D: zs .*= a">vmul_scalar_ip</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> a)
<a name="l00537"></a>00537 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i;
<a name="l00538"></a>00538   <span class="keywordflow">for</span>(i=0;i&lt;N;++i) zs[i*stz] *= a;
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00542"></a><a class="code" href="src_2haar_8c.html#af3c18eb3dce0bc704e8785ba0e16a23a">00542</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#af3c18eb3dce0bc704e8785ba0e16a23a" title="nD: zs .*= a">mul_ip</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> a)
<a name="l00543"></a>00543 { <a class="code" href="src_2haar_8c.html#a7df1a1863594a2089914b3cdcaff0d3d" title="Applies a scalar function z=f(z;a) element-wise and in-place to an n-dimensional...">scalar_ip_op</a>(ndim,shape,zs,stz,a,<a class="code" href="src_2haar_8c.html#abc9de506ab6649485024cc0ed80cf3f3" title="1D: zs .*= a">vmul_scalar_ip</a>);
<a name="l00544"></a>00544 }
<a name="l00545"></a>00545 
<a name="l00547"></a>00547 <span class="keyword">static</span>
<a name="l00548"></a><a class="code" href="src_2haar_8c.html#a60d01ebb3d8b6e89ad11a9266572ded7">00548</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a60d01ebb3d8b6e89ad11a9266572ded7" title="1D: swaps xs and ys. ignores sz.">swap_op</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* zs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stz, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* xs, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> stx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* ys, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> sty)
<a name="l00549"></a>00549 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <span class="keywordflow">for</span>(i=0;i&lt;N;++i)
<a name="l00552"></a>00552   { <span class="keyword">register</span> <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> t;
<a name="l00553"></a>00553     <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *x,*y;
<a name="l00554"></a>00554     x=xs+i*stx, y=ys+i*sty;
<a name="l00555"></a>00555      t=*x;
<a name="l00556"></a>00556     *x=*y;
<a name="l00557"></a>00557     *y=t;
<a name="l00558"></a>00558   }
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00562"></a><a class="code" href="src_2haar_8c.html#a66a0f5f424aa0bf6eeb7bd1cb0f0d990">00562</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a66a0f5f424aa0bf6eeb7bd1cb0f0d990" title="nD: swaps xs and ys.">swap</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *x, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *sx, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *y, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *sy)
<a name="l00563"></a>00563 { <a class="code" href="src_2haar_8c.html#a6b8897306e54a289b9c66efdc4531f18" title="Applies a binary operation z=f(x,y) element-wise across n-dimensional scalar fields...">binary_op</a>(ndim,shape,x,sx,x,sx,y,sy,<a class="code" href="src_2haar_8c.html#a60d01ebb3d8b6e89ad11a9266572ded7" title="1D: swaps xs and ys. ignores sz.">swap_op</a>);
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">//  SCATTER/GATHER  ////////////////////////////////////////////////////////////</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00570"></a>00570 <span class="keyword">static</span>
<a name="l00571"></a><a class="code" href="src_2haar_8c.html#a2ec80c4014c2b36e6d6c1b79f3d9f3c7">00571</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a2ec80c4014c2b36e6d6c1b79f3d9f3c7" title="Internally used utility function.">gather_recursion</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> st, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* left, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* right, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* shape, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *strides)
<a name="l00572"></a>00572 {
<a name="l00573"></a>00573   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> halfN;
<a name="l00574"></a>00574   halfN=N/2;
<a name="l00575"></a>00575   <span class="keywordflow">if</span>(halfN)
<a name="l00576"></a>00576   { <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *ll,*lr,*rl,*rr;
<a name="l00577"></a>00577     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *s;
<a name="l00578"></a>00578     s = shape + idim;
<a name="l00579"></a>00579     ll = left;
<a name="l00580"></a>00580     lr = left+st*halfN;
<a name="l00581"></a>00581     rl = right;
<a name="l00582"></a>00582     rr = right+st*halfN;
<a name="l00583"></a>00583     <a class="code" href="src_2haar_8c.html#a2ec80c4014c2b36e6d6c1b79f3d9f3c7" title="Internally used utility function.">gather_recursion</a>(idim,halfN,st,ll,lr,ndim,shape,strides);
<a name="l00584"></a>00584     <a class="code" href="src_2haar_8c.html#a2ec80c4014c2b36e6d6c1b79f3d9f3c7" title="Internally used utility function.">gather_recursion</a>(idim,halfN,st,rl,rr,ndim,shape,strides);
<a name="l00585"></a>00585     { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> t = *s;
<a name="l00586"></a>00586       *s = halfN;
<a name="l00587"></a>00587       <a class="code" href="src_2haar_8c.html#a66a0f5f424aa0bf6eeb7bd1cb0f0d990" title="nD: swaps xs and ys.">swap</a>(ndim,shape,lr,strides,rl,strides);
<a name="l00588"></a>00588       *s = t;
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590   }
<a name="l00591"></a>00591 }
<a name="l00592"></a>00592 
<a name="l00615"></a><a class="code" href="src_2haar_8c.html#a85a8968ce2abf5afc6ff8dd13eceb83b">00615</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a85a8968ce2abf5afc6ff8dd13eceb83b" title="Gather: zs -&amp;gt; [zs(even indexes) zs(odd indexes)]">gather</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *st)
<a name="l00616"></a>00616 { <span class="comment">//1. transpose so idim on last dim</span>
<a name="l00617"></a>00617   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N,s;
<a name="l00618"></a>00618   N = shape[idim];
<a name="l00619"></a>00619   s = st[idim];
<a name="l00620"></a>00620   <a class="code" href="src_2haar_8c.html#a2ec80c4014c2b36e6d6c1b79f3d9f3c7" title="Internally used utility function.">gather_recursion</a>(idim,N/2,s,z,z+s*(N/2),ndim,shape,st);
<a name="l00621"></a>00621 }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 
<a name="l00625"></a>00625 <span class="keyword">static</span>
<a name="l00626"></a><a class="code" href="src_2haar_8c.html#a08765494d3c5860301a515811e988f79">00626</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a08765494d3c5860301a515811e988f79" title="Internally used utility function.">scatter_recursion</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> st, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* left, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* right, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* shape, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *strides)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> halfN;
<a name="l00629"></a>00629   halfN=N/2;
<a name="l00630"></a>00630   <span class="keywordflow">if</span>(halfN)
<a name="l00631"></a>00631   { <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a> *ll,*lr,*rl,*rr;
<a name="l00632"></a>00632     <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *s;
<a name="l00633"></a>00633     s = shape + idim;
<a name="l00634"></a>00634     ll = left;
<a name="l00635"></a>00635     lr = left+st*halfN;
<a name="l00636"></a>00636     rl = right;
<a name="l00637"></a>00637     rr = right+st*halfN;
<a name="l00638"></a>00638     { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> t = *s;
<a name="l00639"></a>00639       *s = halfN;
<a name="l00640"></a>00640       <a class="code" href="src_2haar_8c.html#a66a0f5f424aa0bf6eeb7bd1cb0f0d990" title="nD: swaps xs and ys.">swap</a>(ndim,shape,lr,strides,rl,strides);
<a name="l00641"></a>00641       *s = t;
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643     <a class="code" href="src_2haar_8c.html#a08765494d3c5860301a515811e988f79" title="Internally used utility function.">scatter_recursion</a>(idim,halfN,st,ll,lr,ndim,shape,strides);
<a name="l00644"></a>00644     <a class="code" href="src_2haar_8c.html#a08765494d3c5860301a515811e988f79" title="Internally used utility function.">scatter_recursion</a>(idim,halfN,st,rl,rr,ndim,shape,strides);
<a name="l00645"></a>00645   }
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00667"></a><a class="code" href="src_2haar_8c.html#a7a770f68691c8bcb6813d55cf1296760">00667</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a7a770f68691c8bcb6813d55cf1296760" title="Inverse of gather().">scatter</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* z, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *st)
<a name="l00668"></a>00668 { <span class="comment">//1. transpose so idim on last dim</span>
<a name="l00669"></a>00669   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N,s;
<a name="l00670"></a>00670   N = shape[idim];
<a name="l00671"></a>00671   s = st[idim];
<a name="l00672"></a>00672   <a class="code" href="src_2haar_8c.html#a08765494d3c5860301a515811e988f79" title="Internally used utility function.">scatter_recursion</a>(idim,N/2,s,z,z+s*(N/2),ndim,shape,st);
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">// KERNEL  /////////////////////////////////////////////////////////////////////</span>
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="comment">// haar kernel: in(1:N) --&gt; out(1:N)</span>
<a name="l00678"></a>00678 <span class="comment">// ---------------------------------</span>
<a name="l00679"></a>00679 <span class="comment">// &#39;out&#39; and &#39;in&#39; must not overlap</span>
<a name="l00680"></a>00680 <span class="comment">// &#39;st*&#39; are the strides</span>
<a name="l00681"></a>00681 <span class="comment">//</span>
<a name="l00682"></a>00682 <span class="comment">// The matrix multiplication underlying this is self-inverse so</span>
<a name="l00683"></a>00683 <span class="comment">// the kernels end up looking very similar!</span>
<a name="l00684"></a>00684 
<a name="l00698"></a>00698 <span class="keyword">static</span>
<a name="l00699"></a><a class="code" href="src_2haar_8c.html#a6f5b8b17e395613992aed1157d73d054">00699</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#a6f5b8b17e395613992aed1157d73d054" title="In-place forward Haar transform kernel.">kernel_ip</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *s, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim)
<a name="l00700"></a>00700 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N,off;                                                               <span class="comment">// e.g. (matlab) - the precise indexing is determined by strides</span>
<a name="l00701"></a>00701   N=shape[idim];
<a name="l00702"></a>00702   off=s[idim];
<a name="l00703"></a>00703   shape[idim]=N/2;
<a name="l00704"></a>00704   s[idim]=2*off;
<a name="l00705"></a>00705   <a class="code" href="src_2haar_8c.html#a8497d55ebb73435021a6b904eca920e4" title="nD: zs = xs + ys">add</a> (ndim, shape, out    , s, out, s, out+off, s);
<a name="l00706"></a>00706   <a class="code" href="src_2haar_8c.html#a7432241a308bae545e35ec116bd048ef" title="nD: zs = xs - 2*ys">sub2</a>(ndim, shape, out+off, s, out, s, out+off, s);
<a name="l00707"></a>00707   shape[idim]=N;
<a name="l00708"></a>00708   s[idim]=off;
<a name="l00709"></a>00709   <a class="code" href="src_2haar_8c.html#af3c18eb3dce0bc704e8785ba0e16a23a" title="nD: zs .*= a">mul_ip</a>(ndim, shape, out, s, <a class="code" href="src_2haar_8c.html#a58e26e9a27c188d602305ec0bc13149a">INVSQRT2</a>);
<a name="l00710"></a>00710   <a class="code" href="src_2haar_8c.html#a85a8968ce2abf5afc6ff8dd13eceb83b" title="Gather: zs -&amp;gt; [zs(even indexes) zs(odd indexes)]">gather</a>(idim, ndim, shape, out, s);
<a name="l00711"></a>00711 }
<a name="l00712"></a>00712 
<a name="l00726"></a>00726 <span class="keyword">static</span>
<a name="l00727"></a><a class="code" href="src_2haar_8c.html#aa1026b08fcda9d6c0ebedefc8bc647a3">00727</a> <span class="keywordtype">void</span> <a class="code" href="src_2haar_8c.html#aa1026b08fcda9d6c0ebedefc8bc647a3" title="In-place inverse Haar transform kernel.">ikernel_ip</a>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *s, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> idim)
<a name="l00728"></a>00728 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> N,off;                                                                 <span class="comment">// e.g. (matlab) - the precise indexing is determined by strides</span>
<a name="l00729"></a>00729   N=shape[idim]/2;
<a name="l00730"></a>00730   off=s[idim];
<a name="l00731"></a>00731   shape[idim]=N;
<a name="l00732"></a>00732   <a class="code" href="src_2haar_8c.html#a8497d55ebb73435021a6b904eca920e4" title="nD: zs = xs + ys">add</a> (ndim, shape, out      , s, out, s, out+off*N, s);
<a name="l00733"></a>00733   <a class="code" href="src_2haar_8c.html#a7432241a308bae545e35ec116bd048ef" title="nD: zs = xs - 2*ys">sub2</a>(ndim, shape, out+off*N, s, out, s, out+off*N, s);
<a name="l00734"></a>00734   shape[idim]=N*2;
<a name="l00735"></a>00735   <a class="code" href="src_2haar_8c.html#af3c18eb3dce0bc704e8785ba0e16a23a" title="nD: zs .*= a">mul_ip</a>(ndim, shape, out, s, <a class="code" href="src_2haar_8c.html#a58e26e9a27c188d602305ec0bc13149a">INVSQRT2</a>);
<a name="l00736"></a>00736   <a class="code" href="src_2haar_8c.html#a7a770f68691c8bcb6813d55cf1296760" title="Inverse of gather().">scatter</a>(idim, ndim, shape, out, s);
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 <span class="comment">//  DOMAINS  ///////////////////////////////////////////////////////////////////</span>
<a name="l00740"></a>00740 
<a name="l00781"></a><a class="code" href="structtag_domain_list.html">00781</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">tagDomainList</a>
<a name="l00782"></a><a class="code" href="structtag_domain_list.html#a19a53a1b90a1fd5f916c3620d3434ee9">00782</a> { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *<a class="code" href="structtag_domain_list.html#a19a53a1b90a1fd5f916c3620d3434ee9" title="Resizable 2d array of shapes (n x ndim).">shapes</a>; 
<a name="l00783"></a><a class="code" href="structtag_domain_list.html#a65e56a86978d11c6e956d33a07162c4a">00783</a>   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> <a class="code" href="structtag_domain_list.html#a65e56a86978d11c6e956d33a07162c4a" title="Shape of the shapes array.">sz</a>[2];   
<a name="l00784"></a><a class="code" href="structtag_domain_list.html#ae69111cfc17484baa81ab65ffb57031f">00784</a>   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> <a class="code" href="structtag_domain_list.html#ae69111cfc17484baa81ab65ffb57031f" title="Tracks the current iteration point.">cursor</a>;  
<a name="l00785"></a>00785 } <a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a>;
<a name="l00786"></a>00786 
<a name="l00790"></a>00790 <span class="keyword">static</span>
<a name="l00791"></a><a class="code" href="group___domain_list_group.html#ga5023a90369ad48437373eaedc4e13e9e">00791</a> <span class="keywordtype">void</span> <a class="code" href="group___domain_list_group.html#ga5023a90369ad48437373eaedc4e13e9e" title="Allocates/Reallocates internal storage as necessary.">DomainListRealloc</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> *<span class="keyword">self</span>, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> n)
<a name="l00792"></a>00792 { <span class="keywordflow">if</span>(self-&gt;shapes)
<a name="l00793"></a>00793     <span class="keyword">self</span>-&gt;shapes = realloc(self-&gt;shapes,<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>)*ndim*n);
<a name="l00794"></a>00794   <span class="keywordflow">else</span>
<a name="l00795"></a>00795     <span class="keyword">self</span>-&gt;shapes = malloc(<span class="keyword">sizeof</span>(<a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>)*ndim*n);
<a name="l00796"></a>00796   <span class="keyword">self</span>-&gt;sz[1]=n;    <span class="comment">//rows</span>
<a name="l00797"></a>00797   <span class="keyword">self</span>-&gt;sz[0]=ndim; <span class="comment">//cols</span>
<a name="l00798"></a>00798 }
<a name="l00799"></a>00799 
<a name="l00801"></a>00801 <span class="keyword">static</span>
<a name="l00802"></a><a class="code" href="group___domain_list_group.html#ga0e04bf496a281eff21bcc835b947f687">00802</a> <span class="keywordtype">void</span> <a class="code" href="group___domain_list_group.html#ga0e04bf496a281eff21bcc835b947f687" title="Releases allocated resources.">DomainListClean</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> *<span class="keyword">self</span>)
<a name="l00803"></a>00803 { <span class="keywordflow">if</span>(<span class="keyword">self</span>)
<a name="l00804"></a>00804   { <span class="keywordflow">if</span>(self-&gt;shapes) free(self-&gt;shapes);
<a name="l00805"></a>00805     <span class="keyword">self</span>-&gt;shapes=0;
<a name="l00806"></a>00806   }
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00810"></a>00810 <span class="keyword">static</span>
<a name="l00811"></a><a class="code" href="group___domain_list_group.html#ga6e0dae01c5255ca7f6e9d3fe0254f8dc">00811</a> <span class="keywordtype">void</span> <a class="code" href="group___domain_list_group.html#ga6e0dae01c5255ca7f6e9d3fe0254f8dc" title="Computes a subdivision plan.">GetDomains</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a>* out, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* dims)
<a name="l00812"></a>00812 { <span class="keywordtype">unsigned</span> n=0;
<a name="l00813"></a>00813   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> i,j;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="comment">// compute number of iterations</span>
<a name="l00816"></a>00816   <span class="keywordflow">for</span>(i=0;i&lt;ndim;++i)
<a name="l00817"></a>00817   { <span class="keywordtype">unsigned</span> v = <a class="code" href="src_2haar_8c.html#a9592a5ae5d02224708d468eb48c9a6f8" title="A fast log2 Algorithm taken from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog...">u64log2</a>(dims[i]);
<a name="l00818"></a>00818     n = (n&gt;v)?n:v; <span class="comment">// max(n,v);</span>
<a name="l00819"></a>00819   }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   <a class="code" href="group___domain_list_group.html#ga5023a90369ad48437373eaedc4e13e9e" title="Allocates/Reallocates internal storage as necessary.">DomainListRealloc</a>(out,ndim,n);
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">// compute domains</span>
<a name="l00824"></a>00824   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *cursor = out-&gt;<a class="code" href="structtag_domain_list.html#a19a53a1b90a1fd5f916c3620d3434ee9" title="Resizable 2d array of shapes (n x ndim).">shapes</a>;
<a name="l00825"></a>00825   <span class="keywordflow">for</span>(j=0;j&lt;ndim;++j)
<a name="l00826"></a>00826     *cursor++ = dims[j];
<a name="l00827"></a>00827   <span class="keywordflow">for</span>(i=1;i&lt;n;++i)
<a name="l00828"></a>00828     <span class="keywordflow">for</span>(j=0;j&lt;ndim;++j)
<a name="l00829"></a>00829     { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> next = cursor[-ndim]&gt;&gt;1;
<a name="l00830"></a>00830       *cursor++ = (next&gt;1)?next:1;
<a name="l00831"></a>00831     }
<a name="l00832"></a>00832 }
<a name="l00833"></a>00833 
<a name="l00835"></a>00835 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00836"></a><a class="code" href="group___domain_list_group.html#gab426b0d2cb02df83a5051d59e9d5a1fa">00836</a> <span class="keywordtype">void</span> <a class="code" href="group___domain_list_group.html#gab426b0d2cb02df83a5051d59e9d5a1fa" title="Sets the iteration point back to the beginning.">DomainListResetCursor</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> *<span class="keyword">self</span>)
<a name="l00837"></a>00837 { <span class="keyword">self</span>-&gt;cursor=0;
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00841"></a>00841 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00842"></a><a class="code" href="group___domain_list_group.html#ga65e667b5a446461c6c083a43fafcdd8d">00842</a> <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* <a class="code" href="group___domain_list_group.html#ga65e667b5a446461c6c083a43fafcdd8d">NextDomain</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a>* <span class="keyword">self</span>)
<a name="l00843"></a>00843 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> t = <span class="keyword">self</span>-&gt;cursor;
<a name="l00844"></a>00844   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> n = <span class="keyword">self</span>-&gt;sz[1];
<a name="l00845"></a>00845   <span class="keyword">self</span>-&gt;cursor = (t+1)%(n+1);   <span class="comment">//inc - one extra for end of sequence</span>
<a name="l00846"></a>00846   <span class="keywordflow">if</span>(t==n)
<a name="l00847"></a>00847     <span class="keywordflow">return</span> 0;
<a name="l00848"></a>00848   <span class="keywordflow">return</span> <span class="keyword">self</span>-&gt;shapes + t*<span class="keyword">self</span>-&gt;sz[0];
<a name="l00849"></a>00849 }
<a name="l00850"></a>00850 
<a name="l00852"></a>00852 <span class="keyword">static</span> <span class="keyword">inline</span>
<a name="l00853"></a><a class="code" href="group___domain_list_group.html#ga0fb6c3bd25dcca815f8eed25b044eed0">00853</a> <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* <a class="code" href="group___domain_list_group.html#ga0fb6c3bd25dcca815f8eed25b044eed0">PrevDomain</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a>* <span class="keyword">self</span>)
<a name="l00854"></a>00854 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> t = <span class="keyword">self</span>-&gt;cursor;
<a name="l00855"></a>00855   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> n = <span class="keyword">self</span>-&gt;sz[1];
<a name="l00856"></a>00856   <span class="keyword">self</span>-&gt;cursor = (t+1)%(n+1);   <span class="comment">//inc - one extra for end of sequence</span>
<a name="l00857"></a>00857   <span class="keywordflow">if</span>(t==n)
<a name="l00858"></a>00858     <span class="keywordflow">return</span> 0;
<a name="l00859"></a>00859   <span class="keywordflow">return</span> <span class="keyword">self</span>-&gt;shapes + (n-t-1)*self-&gt;sz[0];
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00863"></a><a class="code" href="group___domain_list_group.html#gac40e587187cea23a14f3f7fc9bc131f1">00863</a> <span class="keywordtype">void</span> <a class="code" href="group___domain_list_group.html#gac40e587187cea23a14f3f7fc9bc131f1" title="Prints the sub-division plan (for debugging).">PrintDomains</a>(<a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a>* dl)
<a name="l00864"></a>00864 { <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* d,i;
<a name="l00865"></a>00865   <span class="keywordflow">while</span>((d=<a class="code" href="group___domain_list_group.html#ga65e667b5a446461c6c083a43fafcdd8d">NextDomain</a>(dl)))
<a name="l00866"></a>00866   { printf(<span class="stringliteral">&quot;[ %3lld&quot;</span>,d[0]);
<a name="l00867"></a>00867     <span class="keywordflow">for</span>(i=1;i&lt;dl-&gt;<a class="code" href="structtag_domain_list.html#a65e56a86978d11c6e956d33a07162c4a" title="Shape of the shapes array.">sz</a>[0];++i)
<a name="l00868"></a>00868       printf(<span class="stringliteral">&quot;, %3lld&quot;</span>,d[i]);
<a name="l00869"></a>00869     printf(<span class="stringliteral">&quot; ]\n&quot;</span>);
<a name="l00870"></a>00870   }
<a name="l00871"></a>00871 } <span class="comment">//end of DomainListGroup</span>
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 <span class="comment">// TRANSFORM  //////////////////////////////////////////////////////////////////</span>
<a name="l00875"></a>00875 
<a name="l00889"></a><a class="code" href="structtag_haar_workspace.html">00889</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">tagHaarWorkspace</a>
<a name="l00890"></a>00890 {
<a name="l00891"></a><a class="code" href="structtag_haar_workspace.html#aabbab4b9b3c46c646aaad2e2e4f93c1e">00891</a>   <a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> <a class="code" href="structtag_haar_workspace.html#aabbab4b9b3c46c646aaad2e2e4f93c1e" title="The subdivision plan.">domains</a>; 
<a name="l00892"></a>00892 } <a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a>;
<a name="l00893"></a>00893 
<a name="l00898"></a><a class="code" href="group___haar_group.html#gaeced7e537b4898c4064b496007073af4">00898</a> <span class="keywordtype">void</span> <a class="code" href="group___haar_group.html#gaeced7e537b4898c4064b496007073af4" title="Initializes the workspace.">HaarWorkspaceInit</a>(<a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a> *ws)
<a name="l00899"></a>00899 { memset(ws,0,<span class="keyword">sizeof</span>(<a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a>));
<a name="l00900"></a>00900 }
<a name="l00901"></a>00901 
<a name="l00903"></a><a class="code" href="group___haar_group.html#gaa0884d312aa100b4a38bc6ee136fb7c9">00903</a> <span class="keywordtype">void</span> <a class="code" href="group___haar_group.html#gaa0884d312aa100b4a38bc6ee136fb7c9" title="Releases internally allocated resources.">HaarWorkspaceClean</a>(<a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a>* ws)
<a name="l00904"></a>00904 { <a class="code" href="group___domain_list_group.html#ga0e04bf496a281eff21bcc835b947f687" title="Releases allocated resources.">DomainListClean</a>(&amp;ws-&gt;<a class="code" href="structtag_haar_workspace.html#aabbab4b9b3c46c646aaad2e2e4f93c1e" title="The subdivision plan.">domains</a>);
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00947"></a><a class="code" href="group___haar_group.html#ga5b1e4f18ed7d10de0a98b8e882695800">00947</a> <span class="keywordtype">void</span> <a class="code" href="group___haar_group.html#ga5b1e4f18ed7d10de0a98b8e882695800" title="Performs the forward Haar transform.">haar</a>(<a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a>* ws, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* ostrides, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* in, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* istrides)
<a name="l00948"></a>00948 { <a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> *domains;
<a name="l00949"></a>00949   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *domain,i;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951   <a class="code" href="src_2haar_8c.html#ac7424b993ab6cabfa84dcaaca25201a6" title="Copy a subvolume of one n-dimensional scalar field into another scalar field.">copy</a>(ndim,shape,out,ostrides,in,istrides);
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   domains = &amp;ws-&gt;<a class="code" href="structtag_haar_workspace.html#aabbab4b9b3c46c646aaad2e2e4f93c1e" title="The subdivision plan.">domains</a>;
<a name="l00954"></a>00954   <a class="code" href="group___domain_list_group.html#gab426b0d2cb02df83a5051d59e9d5a1fa" title="Sets the iteration point back to the beginning.">DomainListResetCursor</a>(domains);
<a name="l00955"></a>00955   <a class="code" href="group___domain_list_group.html#ga6e0dae01c5255ca7f6e9d3fe0254f8dc" title="Computes a subdivision plan.">GetDomains</a>(domains,ndim,shape);
<a name="l00956"></a>00956   <span class="keywordflow">while</span>((domain=<a class="code" href="group___domain_list_group.html#ga65e667b5a446461c6c083a43fafcdd8d">NextDomain</a>(domains)))
<a name="l00957"></a>00957     <span class="keywordflow">for</span>(i=0;i&lt;ndim;++i)
<a name="l00958"></a>00958       <span class="keywordflow">if</span>(domain[i]&gt;1)
<a name="l00959"></a>00959         <a class="code" href="src_2haar_8c.html#a6f5b8b17e395613992aed1157d73d054" title="In-place forward Haar transform kernel.">kernel_ip</a>(ndim, domain, out, ostrides, i);
<a name="l00960"></a>00960         <span class="comment">//kernel(domain[i],out,ostrides[i],in,istrides[i]);</span>
<a name="l00961"></a>00961         <span class="comment">//kernel_ip(domain[i],out,ostrides[i]);</span>
<a name="l00962"></a>00962 }
<a name="l00963"></a>00963 
<a name="l00987"></a><a class="code" href="group___haar_group.html#gad7ed34c19427b5dcac5de3e8ca8bddf8">00987</a> <span class="keywordtype">void</span> <a class="code" href="group___haar_group.html#gad7ed34c19427b5dcac5de3e8ca8bddf8" title="Performs the inverse Haar transform.">ihaar</a>(<a class="code" href="structtag_haar_workspace.html" title="The HaarWorkspace object keeps track of resources needed to compute the haar() transform...">HaarWorkspace</a>* ws, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> ndim, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* shape, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* out, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* ostrides, <a class="code" href="src_2haar_8c.html#a76f1a9307aa81532397aee3530330119" title="algorithms are implemented for this scalar type">T</a>* in, <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a>* istrides)
<a name="l00988"></a>00988 { <a class="code" href="structtag_domain_list.html" title="Keeps track of sub-volumes for algorithms that rely on recursive subdivision.">DomainList</a> *domains;
<a name="l00989"></a>00989   <a class="code" href="src_2haar_8c.html#a0b59790d1f47c5d2d2d9cb29d6275680" title="pointer offset type">stride_t</a> *domain,i;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <a class="code" href="src_2haar_8c.html#ac7424b993ab6cabfa84dcaaca25201a6" title="Copy a subvolume of one n-dimensional scalar field into another scalar field.">copy</a>(ndim,shape,out,ostrides,in,istrides); <span class="comment">// does nothing if in == out</span>
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   domains = &amp;ws-&gt;<a class="code" href="structtag_haar_workspace.html#aabbab4b9b3c46c646aaad2e2e4f93c1e" title="The subdivision plan.">domains</a>;
<a name="l00994"></a>00994   <a class="code" href="group___domain_list_group.html#gab426b0d2cb02df83a5051d59e9d5a1fa" title="Sets the iteration point back to the beginning.">DomainListResetCursor</a>(domains);
<a name="l00995"></a>00995   <a class="code" href="group___domain_list_group.html#ga6e0dae01c5255ca7f6e9d3fe0254f8dc" title="Computes a subdivision plan.">GetDomains</a>(domains,ndim,shape);
<a name="l00996"></a>00996   <span class="keywordflow">while</span>((domain=<a class="code" href="group___domain_list_group.html#ga0fb6c3bd25dcca815f8eed25b044eed0">PrevDomain</a>(domains)))
<a name="l00997"></a>00997     <span class="keywordflow">for</span>(i=0;i&lt;ndim;++i)
<a name="l00998"></a>00998       <span class="keywordflow">if</span>(domain[i]&gt;1)
<a name="l00999"></a>00999         <a class="code" href="src_2haar_8c.html#aa1026b08fcda9d6c0ebedefc8bc647a3" title="In-place inverse Haar transform kernel.">ikernel_ip</a>(ndim, domain, out, ostrides, i);
<a name="l01000"></a>01000         <span class="comment">//ikernel(domain[i],out,ostrides[i],in,istrides[i]);</span>
<a name="l01001"></a>01001         <span class="comment">//ikernel_ip(domain[i],out,ostrides[i]);</span>
<a name="l01002"></a>01002 }
<a name="l01003"></a>01003  <span class="comment">//end the HaarWorkspaceGroup</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Mar 27 17:22:18 2012 for ndHaar by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
